/* automatically generated by rust-bindgen 0.72.1 */

#![allow(rustdoc::broken_intra_doc_links)]

pub const OPUS_OK: u32 = 0;
pub const OPUS_BAD_ARG: i32 = -1;
pub const OPUS_BUFFER_TOO_SMALL: i32 = -2;
pub const OPUS_INTERNAL_ERROR: i32 = -3;
pub const OPUS_INVALID_PACKET: i32 = -4;
pub const OPUS_UNIMPLEMENTED: i32 = -5;
pub const OPUS_INVALID_STATE: i32 = -6;
pub const OPUS_ALLOC_FAIL: i32 = -7;
pub const OPUS_SET_APPLICATION_REQUEST: u32 = 4000;
pub const OPUS_GET_APPLICATION_REQUEST: u32 = 4001;
pub const OPUS_SET_BITRATE_REQUEST: u32 = 4002;
pub const OPUS_GET_BITRATE_REQUEST: u32 = 4003;
pub const OPUS_SET_MAX_BANDWIDTH_REQUEST: u32 = 4004;
pub const OPUS_GET_MAX_BANDWIDTH_REQUEST: u32 = 4005;
pub const OPUS_SET_VBR_REQUEST: u32 = 4006;
pub const OPUS_GET_VBR_REQUEST: u32 = 4007;
pub const OPUS_SET_BANDWIDTH_REQUEST: u32 = 4008;
pub const OPUS_GET_BANDWIDTH_REQUEST: u32 = 4009;
pub const OPUS_SET_COMPLEXITY_REQUEST: u32 = 4010;
pub const OPUS_GET_COMPLEXITY_REQUEST: u32 = 4011;
pub const OPUS_SET_INBAND_FEC_REQUEST: u32 = 4012;
pub const OPUS_GET_INBAND_FEC_REQUEST: u32 = 4013;
pub const OPUS_SET_PACKET_LOSS_PERC_REQUEST: u32 = 4014;
pub const OPUS_GET_PACKET_LOSS_PERC_REQUEST: u32 = 4015;
pub const OPUS_SET_DTX_REQUEST: u32 = 4016;
pub const OPUS_GET_DTX_REQUEST: u32 = 4017;
pub const OPUS_SET_VBR_CONSTRAINT_REQUEST: u32 = 4020;
pub const OPUS_GET_VBR_CONSTRAINT_REQUEST: u32 = 4021;
pub const OPUS_SET_FORCE_CHANNELS_REQUEST: u32 = 4022;
pub const OPUS_GET_FORCE_CHANNELS_REQUEST: u32 = 4023;
pub const OPUS_SET_SIGNAL_REQUEST: u32 = 4024;
pub const OPUS_GET_SIGNAL_REQUEST: u32 = 4025;
pub const OPUS_GET_LOOKAHEAD_REQUEST: u32 = 4027;
pub const OPUS_GET_SAMPLE_RATE_REQUEST: u32 = 4029;
pub const OPUS_GET_FINAL_RANGE_REQUEST: u32 = 4031;
pub const OPUS_GET_PITCH_REQUEST: u32 = 4033;
pub const OPUS_SET_GAIN_REQUEST: u32 = 4034;
pub const OPUS_GET_GAIN_REQUEST: u32 = 4045;
pub const OPUS_SET_LSB_DEPTH_REQUEST: u32 = 4036;
pub const OPUS_GET_LSB_DEPTH_REQUEST: u32 = 4037;
pub const OPUS_GET_LAST_PACKET_DURATION_REQUEST: u32 = 4039;
pub const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4040;
pub const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4041;
pub const OPUS_SET_PREDICTION_DISABLED_REQUEST: u32 = 4042;
pub const OPUS_GET_PREDICTION_DISABLED_REQUEST: u32 = 4043;
pub const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4046;
pub const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4047;
pub const OPUS_GET_IN_DTX_REQUEST: u32 = 4049;
pub const OPUS_SET_DRED_DURATION_REQUEST: u32 = 4050;
pub const OPUS_GET_DRED_DURATION_REQUEST: u32 = 4051;
pub const OPUS_SET_DNN_BLOB_REQUEST: u32 = 4052;
pub const OPUS_SET_OSCE_BWE_REQUEST: u32 = 4054;
pub const OPUS_GET_OSCE_BWE_REQUEST: u32 = 4055;
pub const OPUS_SET_QEXT_REQUEST: u32 = 4056;
pub const OPUS_GET_QEXT_REQUEST: u32 = 4057;
pub const OPUS_SET_IGNORE_EXTENSIONS_REQUEST: u32 = 4058;
pub const OPUS_GET_IGNORE_EXTENSIONS_REQUEST: u32 = 4059;
pub const OPUS_AUTO: i32 = -1000;
pub const OPUS_BITRATE_MAX: i32 = -1;
pub const OPUS_APPLICATION_VOIP: u32 = 2048;
pub const OPUS_APPLICATION_AUDIO: u32 = 2049;
pub const OPUS_APPLICATION_RESTRICTED_LOWDELAY: u32 = 2051;
pub const OPUS_APPLICATION_RESTRICTED_SILK: u32 = 2052;
pub const OPUS_APPLICATION_RESTRICTED_CELT: u32 = 2053;
pub const OPUS_SIGNAL_VOICE: u32 = 3001;
pub const OPUS_SIGNAL_MUSIC: u32 = 3002;
pub const OPUS_BANDWIDTH_NARROWBAND: u32 = 1101;
pub const OPUS_BANDWIDTH_MEDIUMBAND: u32 = 1102;
pub const OPUS_BANDWIDTH_WIDEBAND: u32 = 1103;
pub const OPUS_BANDWIDTH_SUPERWIDEBAND: u32 = 1104;
pub const OPUS_BANDWIDTH_FULLBAND: u32 = 1105;
pub const OPUS_FRAMESIZE_ARG: u32 = 5000;
pub const OPUS_FRAMESIZE_2_5_MS: u32 = 5001;
pub const OPUS_FRAMESIZE_5_MS: u32 = 5002;
pub const OPUS_FRAMESIZE_10_MS: u32 = 5003;
pub const OPUS_FRAMESIZE_20_MS: u32 = 5004;
pub const OPUS_FRAMESIZE_40_MS: u32 = 5005;
pub const OPUS_FRAMESIZE_60_MS: u32 = 5006;
pub const OPUS_FRAMESIZE_80_MS: u32 = 5007;
pub const OPUS_FRAMESIZE_100_MS: u32 = 5008;
pub const OPUS_FRAMESIZE_120_MS: u32 = 5009;
pub const OPUS_RESET_STATE: u32 = 4028;
pub const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST: u32 = 5120;
pub const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST: u32 = 5122;
pub const OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST: u32 = 6001;
pub const OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST: u32 = 6003;
pub const OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST: u32 = 6005;
pub type opus_int32 = ::std::os::raw::c_int;
pub type opus_uint32 = ::std::os::raw::c_uint;
pub type opus_int16 = ::std::os::raw::c_short;
pub type opus_uint16 = ::std::os::raw::c_ushort;
unsafe extern "C" {
    #[doc = " Converts an opus error code into a human readable string.\n\n @param[in] error <tt>int</tt>: Error number\n @returns Error string"]
    pub fn opus_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the libopus version string.\n\n Applications may look for the substring \"-fixed\" in the version string to\n determine whether they have a fixed-point or floating-point build at\n runtime.\n\n @returns Version string"]
    pub fn opus_get_version_string() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusEncoder</code> structure.\n @param[in] channels <tt>int</tt>: Number of channels.\n                                   This must be 1 or 2.\n @returns The size in bytes.\n @note Since this function does not take the application as input, it will overestimate\n the size required for OPUS_APPLICATION_RESTRICTED_SILK and OPUS_APPLICATION_RESTRICTED_CELT.\n That is generally not a problem, except when trying to know the size to use for a copy."]
    pub fn opus_encoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes an encoder state.\n There are three coding modes:\n\n @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice\n    signals. It enhances the  input signal by high-pass filtering and\n    emphasizing formants and harmonics. Optionally  it includes in-band\n    forward error correction to protect against packet loss. Use this\n    mode for typical VoIP applications. Because of the enhancement,\n    even at high bitrates the output may sound different from the input.\n\n @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most\n    non-voice signals like music. Use this mode for music and mixed\n    (music/voice) content, broadcast, and applications requiring less\n    than 15 ms of coding delay.\n\n @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that\n    disables the speech-optimized mode in exchange for slightly reduced delay.\n    This mode can only be set on an newly initialized or freshly reset encoder\n    because it changes the codec delay.\n\n This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n @param [in] application <tt>int</tt>: Coding mode (one of @ref OPUS_APPLICATION_VOIP, @ref OPUS_APPLICATION_AUDIO, or @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n @param [out] error <tt>int*</tt>: @ref opus_errorcodes\n @note Regardless of the sampling rate and number channels selected, the Opus encoder\n can switch to a lower audio bandwidth or number of channels if the bitrate\n selected is too low. This also means that it is safe to always use 48 kHz stereo input\n and let the encoder optimize the encoding."]
    pub fn opus_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusEncoder;
}
unsafe extern "C" {
    #[doc = " Initializes a previously allocated encoder state\n The memory pointed to by st must be at least the size returned by opus_encoder_get_size().\n This is intended for applications which use their own allocator instead of malloc.\n @see opus_encoder_create(),opus_encoder_get_size()\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n                                      This must be one of 8000, 12000, 16000,\n                                      24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n @param [in] application <tt>int</tt>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_encoder_init(
        st: *mut OpusEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes an Opus frame.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size <tt>int</tt>: Number of samples per channel in the\n                                      input signal.\n                                      This must be an Opus frame size for\n                                      the encoder's sampling rate.\n                                      For example, at 48 kHz the permitted\n                                      values are 120, 240, 480, 960, 1920,\n                                      and 2880.\n                                      Passing in a duration of less than\n                                      10 ms (480 samples at 48 kHz) will\n                                      prevent the encoder from using the LPC\n                                      or hybrid modes.\n @param [out] data <tt>unsigned char*</tt>: Output payload.\n                                            This must contain storage for at\n                                            least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode(
        st: *mut OpusEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Encodes an Opus frame.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] pcm <tt>opus_int32*</tt>: Input signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length is frame_size*channels*sizeof(opus_int32)\n @param [in] frame_size <tt>int</tt>: Number of samples per channel in the\n                                      input signal.\n                                      This must be an Opus frame size for\n                                      the encoder's sampling rate.\n                                      For example, at 48 kHz the permitted\n                                      values are 120, 240, 480, 960, 1920,\n                                      and 2880.\n                                      Passing in a duration of less than\n                                      10 ms (480 samples at 48 kHz) will\n                                      prevent the encoder from using the LPC\n                                      or hybrid modes.\n @param [out] data <tt>unsigned char*</tt>: Output payload.\n                                            This must contain storage for at\n                                            least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode24(
        st: *mut OpusEncoder,
        pcm: *const opus_int32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Encodes an Opus frame from floating point input.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.\n          Samples with a range beyond +/-1.0 are supported but will\n          be clipped by decoders using the integer API and should\n          only be used if it is known that the far end supports\n          extended dynamic range.\n          length is frame_size*channels*sizeof(float)\n @param [in] frame_size <tt>int</tt>: Number of samples per channel in the\n                                      input signal.\n                                      This must be an Opus frame size for\n                                      the encoder's sampling rate.\n                                      For example, at 48 kHz the permitted\n                                      values are 120, 240, 480, 960, 1920,\n                                      and 2880.\n                                      Passing in a duration of less than\n                                      10 ms (480 samples at 48 kHz) will\n                                      prevent the encoder from using the LPC\n                                      or hybrid modes.\n @param [out] data <tt>unsigned char*</tt>: Output payload.\n                                            This must contain storage for at\n                                            least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode_float(
        st: *mut OpusEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().\n @param[in] st <tt>OpusEncoder*</tt>: State to be freed."]
    pub fn opus_encoder_destroy(st: *mut OpusEncoder);
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on an Opus encoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n @param st <tt>OpusEncoder*</tt>: Encoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls or\n                @ref opus_encoderctls.\n @see opus_genericctls\n @see opus_encoderctls"]
    pub fn opus_encoder_ctl(
        st: *mut OpusEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDREDDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDRED {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusDecoder</code> structure.\n @param [in] channels <tt>int</tt>: Number of channels.\n                                    This must be 1 or 2.\n @returns The size in bytes."]
    pub fn opus_decoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a decoder state.\n @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode\n @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes\n\n Internally Opus stores data at 48000 Hz, so that should be the default\n value for Fs. However, the decoder can efficiently decode to buffers\n at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use\n data at the full sample rate, or knows the compressed data doesn't\n use the full frequency range, it can request decoding at a reduced\n rate. Likewise, the decoder is capable of filling in either mono or\n interleaved stereo pcm buffers, at the caller's request."]
    pub fn opus_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusDecoder;
}
unsafe extern "C" {
    #[doc = " Initializes a previously allocated decoder state.\n The state must be at least the size returned by opus_decoder_get_size().\n This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state.\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode\n @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_decoder_init(
        st: *mut OpusDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode an Opus packet.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*\n @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size Number of samples per channel of available space in \\a pcm.\n  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n  then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n  decoded. If no such data is available, the frame is decoded as if it were lost.\n @returns Number of decoded samples per channel or @ref opus_errorcodes"]
    pub fn opus_decode(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode an Opus packet.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*\n @param [out] pcm <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels) representing (or slightly exceeding) 24-bit values. length\n  is frame_size*channels*sizeof(opus_int32)\n @param [in] frame_size Number of samples per channel of available space in \\a pcm.\n  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n  then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n  decoded. If no such data is available, the frame is decoded as if it were lost.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decode24(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode an Opus packet with floating point output.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload\n @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(float)\n @param [in] frame_size Number of samples per channel of available space in \\a pcm.\n  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n  then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n  decoded. If no such data is available the frame is decoded as if it were lost.\n @returns Number of decoded samples per channel or @ref opus_errorcodes"]
    pub fn opus_decode_float(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on an Opus decoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n @param st <tt>OpusDecoder*</tt>: Decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls or\n                @ref opus_decoderctls.\n @see opus_genericctls\n @see opus_decoderctls"]
    pub fn opus_decoder_ctl(
        st: *mut OpusDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().\n @param[in] st <tt>OpusDecoder*</tt>: State to be freed."]
    pub fn opus_decoder_destroy(st: *mut OpusDecoder);
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusDREDDecoder</code> structure.\n @returns The size in bytes."]
    pub fn opus_dred_decoder_get_size() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes an OpusDREDDecoder state.\n @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_dred_decoder_create(error: *mut ::std::os::raw::c_int) -> *mut OpusDREDDecoder;
}
unsafe extern "C" {
    #[doc = " Initializes an <code>OpusDREDDecoder</code> state.\n @param[in] dec <tt>OpusDREDDecoder*</tt>: State to be initialized."]
    pub fn opus_dred_decoder_init(dec: *mut OpusDREDDecoder) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusDREDDecoder</code> allocated by opus_dred_decoder_create().\n @param[in] dec <tt>OpusDREDDecoder*</tt>: State to be freed."]
    pub fn opus_dred_decoder_destroy(dec: *mut OpusDREDDecoder);
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on an Opus DRED decoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n @param dred_dec <tt>OpusDREDDecoder*</tt>: DRED Decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls or\n                @ref opus_decoderctls.\n @see opus_genericctls\n @see opus_decoderctls"]
    pub fn opus_dred_decoder_ctl(
        dred_dec: *mut OpusDREDDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusDRED</code> structure.\n @returns The size in bytes."]
    pub fn opus_dred_get_size() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a DRED state.\n @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_dred_alloc(error: *mut ::std::os::raw::c_int) -> *mut OpusDRED;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusDRED</code> allocated by opus_dred_create().\n @param[in] dec <tt>OpusDRED*</tt>: State to be freed."]
    pub fn opus_dred_free(dec: *mut OpusDRED);
}
unsafe extern "C" {
    #[doc = " Decode an Opus DRED packet.\n @param [in] dred_dec <tt>OpusDRED*</tt>: DRED Decoder state\n @param [in] dred <tt>OpusDRED*</tt>: DRED state\n @param [in] data <tt>char*</tt>: Input payload\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload\n @param [in] max_dred_samples <tt>opus_int32</tt>: Maximum number of DRED samples that may be needed (if available in the packet).\n @param [in] sampling_rate <tt>opus_int32</tt>: Sampling rate used for max_dred_samples argument. Needs not match the actual sampling rate of the decoder.\n @param [out] dred_end <tt>opus_int32*</tt>: Number of non-encoded (silence) samples between the DRED timestamp and the last DRED sample.\n @param [in] defer_processing <tt>int</tt>: Flag (0 or 1). If set to one, the CPU-intensive part of the DRED decoding is deferred until opus_dred_process() is called.\n @returns Offset (positive) of the first decoded DRED samples, zero if no DRED is present, or @ref opus_errorcodes"]
    pub fn opus_dred_parse(
        dred_dec: *mut OpusDREDDecoder,
        dred: *mut OpusDRED,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        max_dred_samples: opus_int32,
        sampling_rate: opus_int32,
        dred_end: *mut ::std::os::raw::c_int,
        defer_processing: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Finish decoding an Opus DRED packet. The function only needs to be called if opus_dred_parse() was called with defer_processing=1.\n The source and destination will often be the same DRED state.\n @param [in] dred_dec <tt>OpusDRED*</tt>: DRED Decoder state\n @param [in] src <tt>OpusDRED*</tt>: Source DRED state to start the processing from.\n @param [out] dst <tt>OpusDRED*</tt>: Destination DRED state to store the updated state after processing.\n @returns @ref opus_errorcodes"]
    pub fn opus_dred_process(
        dred_dec: *mut OpusDREDDecoder,
        src: *const OpusDRED,
        dst: *mut OpusDRED,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode audio from an Opus DRED packet with 16-bit output.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] dred <tt>OpusDRED*</tt>: DRED state\n @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size Number of samples per channel to decode in \\a pcm.\n  frame_size <b>must</b> be a multiple of 2.5 ms.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decoder_dred_decode(
        st: *mut OpusDecoder,
        dred: *const OpusDRED,
        dred_offset: opus_int32,
        pcm: *mut opus_int16,
        frame_size: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode audio from an Opus DRED packet with 24-bit output.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] dred <tt>OpusDRED*</tt>: DRED state\n @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n @param [out] pcm <tt>opus_int32*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size Number of samples per channel to decode in \\a pcm.\n  frame_size <b>must</b> be a multiple of 2.5 ms.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decoder_dred_decode24(
        st: *mut OpusDecoder,
        dred: *const OpusDRED,
        dred_offset: opus_int32,
        pcm: *mut opus_int32,
        frame_size: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode audio from an Opus DRED packet with floating point output.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] dred <tt>OpusDRED*</tt>: DRED state\n @param [in] dred_offset <tt>opus_int32</tt>: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet).\n @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(float)\n @param [in] frame_size Number of samples per channel to decode in \\a pcm.\n  frame_size <b>must</b> be a multiple of 2.5 ms.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decoder_dred_decode_float(
        st: *mut OpusDecoder,
        dred: *const OpusDRED,
        dred_offset: opus_int32,
        pcm: *mut f32,
        frame_size: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Parse an opus packet into one or more frames.\n Opus_decode will perform this operation internally so most applications do\n not need to use this function.\n This function does not copy the frames, the returned pointers are pointers into\n the input packet.\n @param [in] data <tt>char*</tt>: Opus packet to be parsed\n @param [in] len <tt>opus_int32</tt>: size of data\n @param [out] out_toc <tt>char*</tt>: TOC pointer\n @param [out] frames <tt>char*[48]</tt> encapsulated frames\n @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames\n @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)\n @returns number of frames"]
    pub fn opus_packet_parse(
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        out_toc: *mut ::std::os::raw::c_uchar,
        frames: *mut *const ::std::os::raw::c_uchar,
        size: *mut opus_int16,
        payload_offset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the bandwidth of an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet\n @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)\n @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)\n @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)\n @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)\n @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_bandwidth(data: *const ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the number of samples per frame from an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet.\n                                  This must contain at least one byte of\n                                  data.\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n                                     This must be a multiple of 400, or\n                                     inaccurate results will be returned.\n @returns Number of samples per frame."]
    pub fn opus_packet_get_samples_per_frame(
        data: *const ::std::os::raw::c_uchar,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the number of channels from an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet\n @returns Number of channels\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_channels(
        data: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the number of frames in an Opus packet.\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @returns Number of frames\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_frames(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the number of samples of an Opus packet.\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n                                     This must be a multiple of 400, or\n                                     inaccurate results will be returned.\n @returns Number of samples\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_samples(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Checks whether an Opus packet has LBRR.\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @returns 1 is LBRR is present, 0 otherwise\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_has_lbrr(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the number of samples of an Opus packet.\n @param [in] dec <tt>OpusDecoder*</tt>: Decoder state\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @returns Number of samples\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_decoder_get_nb_samples(
        dec: *const OpusDecoder,
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Applies soft-clipping to bring a float signal within the [-1,1] range. If\n the signal is already in that range, nothing is done. If there are values\n outside of [-1,1], then the signal is clipped as smoothly as possible to\n both fit in the range and avoid creating excessive distortion in the\n process.\n @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM\n @param [in] frame_size <tt>int</tt> Number of samples per channel to process\n @param [in] channels <tt>int</tt>: Number of channels\n @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)"]
    pub fn opus_pcm_soft_clip(
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        softclip_mem: *mut f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusRepacketizer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusRepacketizer</code> structure.\n @returns The size in bytes."]
    pub fn opus_repacketizer_get_size() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " (Re)initializes a previously allocated repacketizer state.\n The state must be at least the size returned by opus_repacketizer_get_size().\n This can be used for applications which use their own allocator instead of\n malloc().\n It must also be called to reset the queue of packets waiting to be\n repacketized, which is necessary if the maximum packet duration of 120 ms\n is reached or if you wish to submit packets with a different Opus\n configuration (coding mode, audio bandwidth, frame size, or channel count).\n Failure to do so will prevent a new packet from being added with\n opus_repacketizer_cat().\n @see opus_repacketizer_create\n @see opus_repacketizer_get_size\n @see opus_repacketizer_cat\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to\n                                       (re)initialize.\n @returns A pointer to the same repacketizer state that was passed in."]
    pub fn opus_repacketizer_init(rp: *mut OpusRepacketizer) -> *mut OpusRepacketizer;
}
unsafe extern "C" {
    #[doc = " Allocates memory and initializes the new repacketizer with\n opus_repacketizer_init()."]
    pub fn opus_repacketizer_create() -> *mut OpusRepacketizer;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusRepacketizer</code> allocated by\n opus_repacketizer_create().\n @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed."]
    pub fn opus_repacketizer_destroy(rp: *mut OpusRepacketizer);
}
unsafe extern "C" {
    #[doc = " Add a packet to the current repacketizer state.\n This packet must match the configuration of any packets already submitted\n for repacketization since the last call to opus_repacketizer_init().\n This means that it must have the same coding mode, audio bandwidth, frame\n size, and channel count.\n This can be checked in advance by examining the top 6 bits of the first\n byte of the packet, and ensuring they match the top 6 bits of the first\n byte of any previously submitted packet.\n The total duration of audio in the repacketizer state also must not exceed\n 120 ms, the maximum duration of a single packet, after adding this packet.\n\n The contents of the current repacketizer state can be extracted into new\n packets using opus_repacketizer_out() or opus_repacketizer_out_range().\n\n In order to add a packet with a different configuration or to add more\n audio beyond 120 ms, you must clear the repacketizer state by calling\n opus_repacketizer_init().\n If a packet is too large to add to the current repacketizer state, no part\n of it is added, even if it contains multiple frames, some of which might\n fit.\n If you wish to be able to add parts of such packets, you should first use\n another repacketizer to split the packet into pieces and add them\n individually.\n @see opus_repacketizer_out_range\n @see opus_repacketizer_out\n @see opus_repacketizer_init\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to\n                                       add the packet.\n @param[in] data <tt>const unsigned char*</tt>: The packet data.\n                                                The application must ensure\n                                                this pointer remains valid\n                                                until the next call to\n                                                opus_repacketizer_init() or\n                                                opus_repacketizer_destroy().\n @param len <tt>opus_int32</tt>: The number of bytes in the packet data.\n @returns An error code indicating whether or not the operation succeeded.\n @retval #OPUS_OK The packet's contents have been added to the repacketizer\n                  state.\n @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,\n                              the packet's TOC sequence was not compatible\n                              with previously submitted packets (because\n                              the coding mode, audio bandwidth, frame size,\n                              or channel count did not match), or adding\n                              this packet would increase the total amount of\n                              audio stored in the repacketizer state to more\n                              than 120 ms."]
    pub fn opus_repacketizer_cat(
        rp: *mut OpusRepacketizer,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n                                       construct the new packet.\n @param begin <tt>int</tt>: The index of the first frame in the current\n                            repacketizer state to include in the output.\n @param end <tt>int</tt>: One past the index of the last frame in the\n                          current repacketizer state to include in the\n                          output.\n @param[out] data <tt>const unsigned char*</tt>: The buffer in which to\n                                                 store the output packet.\n @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in\n                                    the output buffer. In order to guarantee\n                                    success, this should be at least\n                                    <code>1276</code> for a single frame,\n                                    or for multiple frames,\n                                    <code>1277*(end-begin)</code>.\n                                    However, <code>1*(end-begin)</code> plus\n                                    the size of all packet data submitted to\n                                    the repacketizer since the last call to\n                                    opus_repacketizer_init() or\n                                    opus_repacketizer_create() is also\n                                    sufficient, and possibly much smaller.\n @returns The total size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of\n                       frames (begin < 0, begin >= end, or end >\n                       opus_repacketizer_get_nb_frames()).\n @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the\n                                complete output packet."]
    pub fn opus_repacketizer_out_range(
        rp: *mut OpusRepacketizer,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Return the total number of frames contained in packet data submitted to\n the repacketizer state so far via opus_repacketizer_cat() since the last\n call to opus_repacketizer_init() or opus_repacketizer_create().\n This defines the valid range of packets that can be extracted with\n opus_repacketizer_out_range() or opus_repacketizer_out().\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the\n                                       frames.\n @returns The total number of frames contained in the packet data submitted\n          to the repacketizer state."]
    pub fn opus_repacketizer_get_nb_frames(rp: *mut OpusRepacketizer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n This is a convenience routine that returns all the data submitted so far\n in a single packet.\n It is equivalent to calling\n @code\n opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),\n                             data, maxlen)\n @endcode\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n                                       construct the new packet.\n @param[out] data <tt>const unsigned char*</tt>: The buffer in which to\n                                                 store the output packet.\n @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in\n                                    the output buffer. In order to guarantee\n                                    success, this should be at least\n                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.\n                                    However,\n                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code>\n                                    plus the size of all packet data\n                                    submitted to the repacketizer since the\n                                    last call to opus_repacketizer_init() or\n                                    opus_repacketizer_create() is also\n                                    sufficient, and possibly much smaller.\n @returns The total size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the\n                                complete output packet."]
    pub fn opus_repacketizer_out(
        rp: *mut OpusRepacketizer,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Pads a given Opus packet to a larger size (possibly changing the TOC sequence).\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to pad.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.\n                                 This must be at least as large as len.\n @returns an error code\n @retval #OPUS_OK \\a on success.\n @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove all padding from a given Opus packet and rewrite the TOC sequence to\n minimize space usage.\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to strip.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @returns The new size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG \\a len was less than 1.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_unpad(data: *mut ::std::os::raw::c_uchar, len: opus_int32) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to pad.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.\n                                 This must be at least 1.\n @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n                                 This must be at least as large as len.\n @returns an error code\n @retval #OPUS_OK \\a on success.\n @retval #OPUS_BAD_ARG \\a len was less than 1.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to\n minimize space usage.\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to strip.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n                                 This must be at least 1.\n @returns The new size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_unpad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSDecoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Gets the size of an OpusMSEncoder structure.\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_encoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
unsafe extern "C" {
    pub fn opus_multistream_surround_encoder_get_size(
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a multistream encoder state.\n Call opus_multistream_encoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than the number of channels.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than the number of input channels.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    encoded channels to input channels, as described in\n                    @ref opus_multistream. As an extra constraint, the\n                    multistream encoder does not allow encoding coupled\n                    streams for which one channel is unused since this\n                    is never a good idea.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_multistream_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
unsafe extern "C" {
    pub fn opus_multistream_surround_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
unsafe extern "C" {
    #[doc = " Initialize a previously allocated multistream encoder state.\n The memory pointed to by \\a st must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_multistream_encoder_create\n @see opus_multistream_encoder_get_size\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than the number of channels.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than the number of input channels.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    encoded channels to input channels, as described in\n                    @ref opus_multistream. As an extra constraint, the\n                    multistream encoder does not allow encoding coupled\n                    streams for which one channel is unused since this\n                    is never a good idea.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_multistream_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opus_multistream_surround_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a multistream Opus frame.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved\n                                            samples.\n                                            This must contain\n                                            <code>frame_size*channels</code>\n                                            samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode(
        st: *mut OpusMSEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a multistream Opus frame.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param[in] pcm <tt>const opus_int32*</tt>: The input signal as interleaved\n                                            samples representing (or slightly exceeding) 24-bit values.\n                                            This must contain\n                                            <code>frame_size*channels</code>\n                                            samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode24(
        st: *mut OpusMSEncoder,
        pcm: *const opus_int32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a multistream Opus frame from floating point input.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param[in] pcm <tt>const float*</tt>: The input signal as interleaved\n                                       samples with a normal range of\n                                       +/-1.0.\n                                       Samples with a range beyond +/-1.0\n                                       are supported but will be clipped by\n                                       decoders using the integer API and\n                                       should only be used if it is known\n                                       that the far end supports extended\n                                       dynamic range.\n                                       This must contain\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode_float(
        st: *mut OpusMSEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusMSEncoder</code> allocated by\n opus_multistream_encoder_create().\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to be freed."]
    pub fn opus_multistream_encoder_destroy(st: *mut OpusMSEncoder);
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus encoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_encoderctls, or @ref opus_multistream_ctls.\n @see opus_genericctls\n @see opus_encoderctls\n @see opus_multistream_ctls"]
    pub fn opus_multistream_encoder_ctl(
        st: *mut OpusMSEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusMSDecoder</code> structure.\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_decoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a multistream decoder state.\n Call opus_multistream_decoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    coded channels to output channels, as described in\n                    @ref opus_multistream.\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_multistream_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSDecoder;
}
unsafe extern "C" {
    #[doc = " Initialize a previously allocated decoder state object.\n The memory pointed to by \\a st must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_multistream_decoder_create\n @see opus_multistream_deocder_get_size\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    coded channels to output channels, as described in\n                    @ref opus_multistream.\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_multistream_decoder_init(
        st: *mut OpusMSDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a multistream Opus packet.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a multistream Opus packet.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int32*</tt>: Output signal, with interleaved\n                                       samples representing (or slightly exceeding) 24-bit values.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode24(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a multistream Opus packet with floating point output.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode_float(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus decoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_decoderctls, or @ref opus_multistream_ctls.\n @see opus_genericctls\n @see opus_decoderctls\n @see opus_multistream_ctls"]
    pub fn opus_multistream_decoder_ctl(
        st: *mut OpusMSDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusMSDecoder</code> allocated by\n opus_multistream_decoder_create().\n @param st <tt>OpusMSDecoder</tt>: Multistream decoder state to be freed."]
    pub fn opus_multistream_decoder_destroy(st: *mut OpusMSDecoder);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusProjectionEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusProjectionDecoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Gets the size of an OpusProjectionEncoder structure.\n @param channels <tt>int</tt>: The total number of input channels to encode.\n                               This must be no more than 255.\n @param mapping_family <tt>int</tt>: The mapping family to use for selecting\n                                     the appropriate projection.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_projection_ambisonics_encoder_get_size(
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a projection encoder state.\n Call opus_projection_encoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param mapping_family <tt>int</tt>: The mapping family to use for selecting\n                                     the appropriate projection.\n @param[out] streams <tt>int *</tt>: The total number of streams that will\n                                     be encoded from the input.\n @param[out] coupled_streams <tt>int *</tt>: Number of coupled (2 channel)\n                                 streams that will be encoded from the input.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_projection_ambisonics_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusProjectionEncoder;
}
unsafe extern "C" {
    #[doc = " Initialize a previously allocated projection encoder state.\n The memory pointed to by \\a st must be at least the size returned by\n opus_projection_ambisonics_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_projection_ambisonics_encoder_create\n @see opus_projection_ambisonics_encoder_get_size\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than the number of channels.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than the number of input channels.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_projection_ambisonics_encoder_init(
        st: *mut OpusProjectionEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a projection Opus frame.\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.\n @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved\n                                            samples.\n                                            This must contain\n                                            <code>frame_size*channels</code>\n                                            samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_encode(
        st: *mut OpusProjectionEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a projection Opus frame.\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.\n @param[in] pcm <tt>const opus_int32*</tt>: The input signal as interleaved\n                                            samples representing (or slightly exceeding) 24-bit values.\n                                            This must contain\n                                            <code>frame_size*channels</code>\n                                            samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_encode24(
        st: *mut OpusProjectionEncoder,
        pcm: *const opus_int32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Encodes a projection Opus frame from floating point input.\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.\n @param[in] pcm <tt>const float*</tt>: The input signal as interleaved\n                                       samples with a normal range of\n                                       +/-1.0.\n                                       Samples with a range beyond +/-1.0\n                                       are supported but will be clipped by\n                                       decoders using the integer API and\n                                       should only be used if it is known\n                                       that the far end supports extended\n                                       dynamic range.\n                                       This must contain\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_encode_float(
        st: *mut OpusProjectionEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusProjectionEncoder</code> allocated by\n opus_projection_ambisonics_encoder_create().\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state to be freed."]
    pub fn opus_projection_encoder_destroy(st: *mut OpusProjectionEncoder);
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on a projection Opus encoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusProjectionEncoder*</tt>: Projection encoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_encoderctls, @ref opus_multistream_ctls, or\n                @ref opus_projection_ctls\n @see opus_genericctls\n @see opus_encoderctls\n @see opus_multistream_ctls\n @see opus_projection_ctls"]
    pub fn opus_projection_encoder_ctl(
        st: *mut OpusProjectionEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the size of an <code>OpusProjectionDecoder</code> structure.\n @param channels <tt>int</tt>: The total number of output channels.\n                               This must be no more than 255.\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_projection_decoder_get_size(
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
unsafe extern "C" {
    #[doc = " Allocates and initializes a projection decoder state.\n Call opus_projection_decoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix\n                         that mapping from coded channels to output channels,\n                         as described in @ref opus_projection and\n                         @ref opus_projection_ctls.\n @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the\n                                                  demixing matrix, as\n                                                  described in @ref\n                                                  opus_projection_ctls.\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_projection_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        demixing_matrix: *mut ::std::os::raw::c_uchar,
        demixing_matrix_size: opus_int32,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusProjectionDecoder;
}
unsafe extern "C" {
    #[doc = " Initialize a previously allocated projection decoder state object.\n The memory pointed to by \\a st must be at least the size returned by\n opus_projection_decoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_projection_decoder_create\n @see opus_projection_deocder_get_size\n @param st <tt>OpusProjectionDecoder*</tt>: Projection encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] demixing_matrix <tt>const unsigned char[demixing_matrix_size]</tt>: Demixing matrix\n                         that mapping from coded channels to output channels,\n                         as described in @ref opus_projection and\n                         @ref opus_projection_ctls.\n @param demixing_matrix_size <tt>opus_int32</tt>: The size in bytes of the\n                                                  demixing matrix, as\n                                                  described in @ref\n                                                  opus_projection_ctls.\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_projection_decoder_init(
        st: *mut OpusProjectionDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        demixing_matrix: *mut ::std::os::raw::c_uchar,
        demixing_matrix_size: opus_int32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a projection Opus packet.\n @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_decode(
        st: *mut OpusProjectionDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a projection Opus packet.\n @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int32*</tt>: Output signal, with interleaved\n                                       samples representing (or slightly exceeding) 24-bit values.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_decode24(
        st: *mut OpusProjectionDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a projection Opus packet with floating point output.\n @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_projection_decode_float(
        st: *mut OpusProjectionDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a CTL function on a projection Opus decoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusProjectionDecoder*</tt>: Projection decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_decoderctls, @ref opus_multistream_ctls, or\n                @ref opus_projection_ctls.\n @see opus_genericctls\n @see opus_decoderctls\n @see opus_multistream_ctls\n @see opus_projection_ctls"]
    pub fn opus_projection_decoder_ctl(
        st: *mut OpusProjectionDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Frees an <code>OpusProjectionDecoder</code> allocated by\n opus_projection_decoder_create().\n @param st <tt>OpusProjectionDecoder</tt>: Projection decoder state to be freed."]
    pub fn opus_projection_decoder_destroy(st: *mut OpusProjectionDecoder);
}
